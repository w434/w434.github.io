<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法A 第二章线性表 | w434's blog</title><meta name="author" content="w434"><meta name="copyright" content="w434"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线性表的概念线性表的抽象数据类型 线性表的定义：线性表(简称为表)是零个或多个元素的有穷序列L&#x3D;(k0,k1,…,kn-1)；线性表是由称为元素的数据项组成的一种有限且有序的序列，这些元素也称为结点或表目  线性表的逻辑结构：L&#x3D;&lt;K,R&gt;其中，K&#x3D;{k0,k1,…,kn-1}，R&#x3D;{r:线性关系}。  i称为ki的索引或下表。所含元素的个数称为">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法A 第二章线性表">
<meta property="og:url" content="http://example.com/post/a9e6fa8c.html">
<meta property="og:site_name" content="w434&#39;s blog">
<meta property="og:description" content="线性表的概念线性表的抽象数据类型 线性表的定义：线性表(简称为表)是零个或多个元素的有穷序列L&#x3D;(k0,k1,…,kn-1)；线性表是由称为元素的数据项组成的一种有限且有序的序列，这些元素也称为结点或表目  线性表的逻辑结构：L&#x3D;&lt;K,R&gt;其中，K&#x3D;{k0,k1,…,kn-1}，R&#x3D;{r:线性关系}。  i称为ki的索引或下表。所含元素的个数称为">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg">
<meta property="article:published_time" content="2024-09-18T12:43:00.000Z">
<meta property="article:modified_time" content="2024-10-31T12:24:20.198Z">
<meta property="article:author" content="w434">
<meta property="article:tag" content="数据结构与算法A">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/a9e6fa8c.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法A 第二章线性表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-31 20:24:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/07/16/lsEXfWtGT6eRu7k.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa-solid fa-school"></i><span> 课程笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-face-smile"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/matches/"><i class="fa-fw fa-solid fa-futbol"></i><span> 足球赛事</span></a></li><li><a class="site-page child" href="/chess/"><i class="fa-fw fa-solid fa-chess"></i><span> 国际象棋</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-solid fa-film"></i><span> 影评&amp;演出评论&amp;书评</span></a></li><li><a class="site-page child" href="/jottings/"><i class="fa-fw fa-solid fa-book"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/varietyShow/"><i class="fa-fw fa-solid fa-tv"></i><span> 综艺</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa-solid fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/musics/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="w434's blog"><span class="site-name">w434's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa-solid fa-school"></i><span> 课程笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-face-smile"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/matches/"><i class="fa-fw fa-solid fa-futbol"></i><span> 足球赛事</span></a></li><li><a class="site-page child" href="/chess/"><i class="fa-fw fa-solid fa-chess"></i><span> 国际象棋</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-solid fa-film"></i><span> 影评&amp;演出评论&amp;书评</span></a></li><li><a class="site-page child" href="/jottings/"><i class="fa-fw fa-solid fa-book"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/varietyShow/"><i class="fa-fw fa-solid fa-tv"></i><span> 综艺</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa-solid fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/musics/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法A 第二章线性表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-18T12:43:00.000Z" title="Created 2024-09-18 20:43:00">2024-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-10-31T12:24:20.198Z" title="Updated 2024-10-31 20:24:20">2024-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/">数据结构与算法A</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法A 第二章线性表"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h1><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><ul>
<li><p>线性表的定义：线性表(简称为表)是零个或多个元素的有穷序列L&#x3D;(k0,k1,…,kn-1)；线性表是由称为元素的数据项组成的一种有限且有序的序列，这些元素也称为结点或表目</p>
</li>
<li><p>线性表的逻辑结构：L&#x3D;&lt;K,R&gt;其中，K&#x3D;{k0,k1,…,kn-1}，R&#x3D;{r:线性关系}。</p>
</li>
<li><p>i称为ki的索引或下表。所含元素的个数称为表的长度。长度为0的表称为空表。k0是第一个元素kn-1是最后一个元素。ki是ki+1的前驱，ki+1是ki的后继</p>
</li>
<li><p>唯一开始的结点：没有前驱；唯一终止的结点：没有后继。内部节点：有唯一的直接前驱也有一个唯一的直接后继</p>
</li>
<li><p>线性表的关系r是前驱关系，应具有反对称性和传递性</p>
</li>
<li><p>要求：</p>
<ol>
<li>内部结点具有相同的数据类型</li>
<li>每个元素都有自己的位置[0,n-1]</li>
</ol>
</li>
<li><p>在线性表上实施的操作：</p>
<ol>
<li>对整个表的操作：创建或置空一个线性表、合并两个线性表、判断线性表是否为空或满</li>
<li>对表中元素的操作：查找线性表中满足一定条件的元素、在线性表中插入或删除指定元素</li>
</ol>
</li>
<li><p>线性表ADT：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;                               <span class="comment">//置空线性表</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;                             <span class="comment">//线性表为空返回true;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(<span class="type">const</span> T value)</span></span>;                 <span class="comment">//表尾添加元素v，表长+1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p,<span class="type">const</span> T value)</span></span>;     <span class="comment">//在p位置上插入元素value，表长+1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">delete</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p)</span></span>;                   <span class="comment">//删除p位置的元素，表长-1</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p,T&amp; value)</span></span>;        <span class="comment">//把位置p的元素值返回到变量value中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p,<span class="type">const</span> T value)</span></span>;   <span class="comment">//用value修改位置p的元素值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setPos</span><span class="params">(<span class="type">int</span> &amp; p,<span class="type">const</span> T value)</span></span>;         <span class="comment">//把值为value的元素所在的位置返回到变量p中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setPos</span><span class="params">(<span class="type">int</span> pos)</span></span>;                       <span class="comment">//设置当前下标</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setStart</span><span class="params">()</span></span>;                            <span class="comment">//把当前下标移动到表头</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">setEnd</span><span class="params">()</span></span>;                              <span class="comment">//把当前下标移动到表尾</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">prev</span><span class="params">()</span></span>;                                <span class="comment">//把当前下标左移一位</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">next</span><span class="params">()</span></span>;                                <span class="comment">//把当前下标右移一位  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线性表的存储结构"><a href="#线性表的存储结构" class="headerlink" title="线性表的存储结构"></a>线性表的存储结构</h2><ul>
<li>线性表的存储结构主要有两类：<ol>
<li>定长、静态的顺序存储结构，简称顺序表：数组模式。又称为向量型的一维数据结构。为线性表分配一块连续的存储空间，随机访问，但长度固定。地址相邻表达为线性关系</li>
<li>变长、动态的线性存储结构，简称链接式存储结构，简称链表：链表模式。用指针来表示元素间的线性关系，前驱和后继关系通过指针来连接。对长度不加限制，可申请更大的空间</li>
</ol>
</li>
</ul>
<h2 id="线性表运算分类"><a href="#线性表运算分类" class="headerlink" title="线性表运算分类"></a>线性表运算分类</h2><ul>
<li><p>list()：创建线性表的一个实例(即构造函数)</p>
</li>
<li><p>~list()：线性表消亡(即析构函数)</p>
</li>
<li><p>获取有关当前线性表的信息</p>
<ol>
<li>位置寻内容</li>
<li>内容找位置</li>
</ol>
</li>
<li><p>访问线性表并且改变线性表的内容或结构，包括插入、删除、更改、清空线性表等</p>
</li>
<li><p>辅助管理操作，例如游标、求当前长度</p>
</li>
</ul>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><ul>
<li><p>顺序表(向量)：按顺序方式存储的线性表。顺序表中的每个元素按其顺序有唯一的索引值，又称下标值，用来访问元素的内容</p>
</li>
<li><p>主要特性：</p>
<ol>
<li>元素的类型相同</li>
<li>存储在连续的空间中，每个元素唯一的索引值，读写元素方便</li>
<li>使用常数作为向量长度，程序运行时保持不变</li>
</ol>
</li>
</ul>
<h2 id="顺序表的类定义"><a href="#顺序表的类定义" class="headerlink" title="顺序表的类定义"></a>顺序表的类定义</h2><p><img src="https://s2.loli.net/2024/09/23/6eplTAvzD7OKJPx.png" alt=" 2024-09-23 102506.png"></p>
<ul>
<li>假设每个元素占用L个存储单元，设顺序表开始的结点k0的存储位置记为b&#x3D;loc(k0)，设其为首地址或基地址，下标为i的元素ki的存储位置则为loc(ki)&#x3D;b+i*L。可知每个元素的存储位置都与起始位置相差一个位序成正比的常数。确定了基地址，任意元素的地址都可以方便的计算出来<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Boolean</span> &#123;False,True&#125;;</span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> Max_length = <span class="number">100</span>;</span><br><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;     <span class="comment">//假定顺序表的元素类型T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">list</span>  </span><br><span class="line">&#123;                              <span class="comment">//顺序表，向量</span></span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        T* nodelist;                <span class="comment">//私有变量，存储顺序表实例的向量</span></span><br><span class="line">        <span class="type">int</span>  maxSize;              <span class="comment">//私有变量，顺序表实例的最大长度</span></span><br><span class="line">        <span class="type">int</span>  curLen; 	          <span class="comment">//私有变量，顺序表实例的当前长度</span></span><br><span class="line">        <span class="type">int</span>  position;	          <span class="comment">//私有变量，当前处理位置</span></span><br><span class="line">    <span class="keyword">public</span>: 	                                    </span><br><span class="line">          <span class="built_in">list</span>(<span class="type">const</span>  <span class="type">int</span> size);          <span class="comment">//构造算子，实参是表实例的最大长度</span></span><br><span class="line">          ~<span class="built_in">list</span>();                              <span class="comment">//析构算子，用于将该表实例删去</span></span><br><span class="line">          <span class="built_in">arrList</span>(<span class="type">const</span> <span class="type">int</span> size) </span><br><span class="line">          &#123;<span class="comment">// 创建一个新顺序表，参数为表实例的最大长度</span></span><br><span class="line">              maxSize = size;</span><br><span class="line">              aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">              curLen = position = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          ~<span class="built_in">arrList</span>() </span><br><span class="line">          &#123; <span class="comment">// 析构函数，用于消除该表实例</span></span><br><span class="line">              <span class="keyword">delete</span> [] aList;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">          </span>&#123; <span class="comment">// 将顺序表存储的内容清除，成为空表</span></span><br><span class="line">              <span class="keyword">delete</span> [] aList;</span><br><span class="line">              curLen = position = <span class="number">0</span>;</span><br><span class="line">              aList = <span class="keyword">new</span> T[maxSize];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="function"><span class="type">void</span>  <span class="title">clear</span><span class="params">()</span></span>;                                 <span class="comment">//将顺序表存储的内容清除，成为空表</span></span><br><span class="line">          <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>;                                  <span class="comment">//返回此顺序表的当前实际长度</span></span><br><span class="line">          <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(<span class="type">const</span>  T value)</span></span>;      <span class="comment">//表尾增一新元素，表长加1 </span></span><br><span class="line">          <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span>  <span class="type">int</span> p, <span class="type">const</span> T value)</span></span>; <span class="comment">//在p位置插入值value，表长加1</span></span><br><span class="line">          <span class="function"><span class="type">bool</span> <span class="title">delete</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p)</span></span>;              <span class="comment">//删去位置p的元素，表长减1；</span></span><br><span class="line">          <span class="function"><span class="type">bool</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> T value)</span></span>;	       <span class="comment">//用value修改位置p的元素值   </span></span><br><span class="line">          <span class="function"><span class="type">bool</span>  <span class="title">getvalue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> p, T &amp; value)</span></span>;  <span class="comment">//把p位置值返回到变量value中</span></span><br><span class="line">         <span class="comment">// 查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">          <span class="function"><span class="type">bool</span> <span class="title">getPos</span><span class="params">(<span class="type">int</span> &amp;p, <span class="type">const</span> T value)</span></span>;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="顺序表的运算实现"><a href="#顺序表的运算实现" class="headerlink" title="顺序表的运算实现"></a>顺序表的运算实现</h2><h3 id="顺序表的检索"><a href="#顺序表的检索" class="headerlink" title="顺序表的检索"></a>顺序表的检索</h3><ul>
<li><p>顺序表的检索运算可以分为按位置的查找和按内容的查找两类，前者在顺序表中可以直接计算其存储地址，可以在常数时间内存取该元素</p>
</li>
<li><p>按内容查找目的: 查找某个值的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  	<span class="comment">// 假定顺序表的元素类型为T </span></span><br><span class="line"><span class="type">bool</span> arrList&lt;T&gt; :: <span class="built_in">getPos</span> (<span class="type">int</span> &amp; p, <span class="type">const</span> T value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;                                     <span class="comment">// 元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) 	<span class="comment">// 依次比较</span></span><br><span class="line">        <span class="keyword">if</span> (value == aList[i]) </span><br><span class="line">        &#123;	 <span class="comment">// 下标为i的元素与value相等</span></span><br><span class="line">            p = i;		<span class="comment">// 将下标由参数p返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 顺序表没有元素值为value的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/J3z5oBEjLXx8HOT.png" alt=" 2024-09-23 103626.png"></p>
<h3 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h3><ul>
<li><p>bool insert(const int p, const T vlaue)，在当前下标 p&#x3D; t 位置插入元素新值value</p>
</li>
<li><p>插入的限制条件：除了涉及被更新的那个元素之外，其他元素的线性关系的相对顺序应该保持不变</p>
</li>
<li><p>条件判断：</p>
<ol>
<li>当前下标[0，curr_len]；（是否越界？）</li>
<li>当前长度（&lt;msize）（是否溢出?）</li>
<li>要先移动，腾出空间，再插入！</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/adZmEGi6F5gozyQ.png" alt=" 2024-09-23 104426.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  		<span class="comment">// 假定顺序表的元素类型为T</span></span><br><span class="line"><span class="type">bool</span> arrList&lt;T&gt; :: <span class="built_in">insert</span>(<span class="type">int</span> p, <span class="type">const</span> T value) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &gt;= maxSize) 	  <span class="comment">// 检查顺序表是否溢出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen)  	  <span class="comment">// 检查插入位置是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = curLen; i &gt; p; i--)</span><br><span class="line">        aList[i] = aList[i<span class="number">-1</span>];   	  <span class="comment">// 从表尾curLen -1起往右移到p</span></span><br><span class="line">    aList[p] = value;              	  <span class="comment">// 位置p处插入新元素</span></span><br><span class="line">    curLen++;               	  <span class="comment">// 表的实际长度增1 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法的主要代价：元素的移动，元素总个数为n，各个位置插入的概率相等为p＝1&#x2F;(n+1)</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/fPbCOiFjY9AQhoX.png" alt=" 2024-09-23 105111.png"></p>
<h3 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h3><ul>
<li><p>Delete (const int p)，下标t位置值作为返回值，并删去该元素</p>
</li>
<li><p>事先需要检查是否为空表，只有在非空表时才能进行元素删除</p>
</li>
<li><p>条件判断：</p>
<ol>
<li>当前下标[0，curr_len）删除位置是否有效？</li>
<li>当前长度（&gt;0）是否向下溢出？</li>
<li>删除后，t后元素向前依次移动！<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  	<span class="comment">// 顺序表的元素类型为T</span></span><br><span class="line"><span class="type">bool</span> arrList&lt;T&gt; :: <span class="built_in">delete</span>(<span class="type">int</span> p) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (curLen &lt;= <span class="number">0</span> )   	                <span class="comment">// 检查顺序表是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">if</span> (p &lt; <span class="number">0</span> || p &gt; curLen<span class="number">-1</span>)            <span class="comment">// 检查删除位置是否合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = p; i &lt; curLen<span class="number">-1</span>; i++)</span><br><span class="line">        aList[i] = aList[i<span class="number">+1</span>];   	  <span class="comment">// 从位置p开始每个元素左移直到curLen,</span></span><br><span class="line">    curLen--;               		  <span class="comment">// 表的实际长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>算法的时间代价与插入操作相似，O(n)</p>
</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li><p>顺序表的缺陷：</p>
<ol>
<li>大小固定，改变顺序表的大小需要重新创建一个新的顺序表并复制原有数据</li>
<li>逻辑关系是通过物理位置的相邻来表示的，增删元素代价高</li>
</ol>
</li>
<li><p>链表可以看成一组既存储数据又存储相互连接信息的结点集合，由称为指针的域来按照线性表的后继关系链接结点</p>
</li>
<li><p>链表的特点：</p>
<ol>
<li>指针指向保持前驱关系，节点不必物理相邻</li>
<li>动态申请&#x2F;释放空间，长度动态变化（插入&#x2F;删除）</li>
</ol>
</li>
</ul>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ul>
<li>单链表：每个节点只包含指向其后继的指针</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/lVeUkY6S9yLnAtN.png" alt=" 2024-09-23 134020.png"></p>
<ul>
<li><p>单链表的存储结点由两部分组成：</p>
<ol>
<li>存放结点数据，称为data域</li>
<li>存放指向后继结点的指针域next</li>
</ol>
</li>
<li><p>对于没有后继结点的终止结点而言，其next域为空指针NULL</p>
</li>
<li><p>单链表的结点定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T data;                 <span class="comment">//用于保存节点元素的内容</span></span><br><span class="line">        Link&lt;T&gt; * next;         <span class="comment">//指向后继结点的指针</span></span><br><span class="line">        <span class="built_in">Link</span>(<span class="type">const</span> T info,<span class="type">const</span> Link&lt;T&gt; * nextValue = <span class="literal">NULL</span>)     <span class="comment">//具有两个参数的Link构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            data = info;</span><br><span class="line">            next = nextValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Link</span>(<span class="type">const</span> Link&lt;T&gt; * nextValue)           <span class="comment">//具有一个参数的构造函数</span></span><br><span class="line">        &#123;</span><br><span class="line">            next = nextValue;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Link是由自身来定义的，因为其中的next域指向正在定义的类型本身，这种类型称为自引用型</p>
</li>
<li><p>由于单链表中的各个结点的存储地址并不连续，因此访问任何结点都只能从头至臻开始沿着结点的next域来进行</p>
</li>
<li><p>单链表的ADT：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lnkList</span> : <span class="keyword">public</span> List&lt;T&gt;  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        Link&lt;T&gt; *head, tail; 		<span class="comment">// 单链表的头、尾指针</span></span><br><span class="line">        <span class="function">Link&lt;T&gt; *<span class="title">setPos</span><span class="params">(<span class="type">int</span> p)</span></span>;	                  <span class="comment">// 返回线性表指向第p个元素的指针值</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="built_in">lnkList</span>(<span class="type">int</span> s);	 		<span class="comment">// 构造函数</span></span><br><span class="line">        ~<span class="built_in">lnkList</span>();		 	<span class="comment">// 析构函数</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>; 	 		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; 	 		<span class="comment">// 将链表存储的内容清除，成为空表</span></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span></span>;                   		<span class="comment">// 返回此顺序表的当前实际长度</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">append</span><span class="params">(T value)</span></span>;		<span class="comment">// 在表尾添加一个元素value，表的长度增1</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, T value)</span></span>;	 	<span class="comment">// 在位置p插入一个元素value，表的长度增1</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">delete</span><span class="params">(<span class="type">int</span> p)</span></span>; 	 		<span class="comment">// 删除位置p上的元素，表的长度减 1</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">getValue</span><span class="params">(<span class="type">int</span> p, T value)</span></span>;	 	<span class="comment">// 返回位置p的元素值 </span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">getPos</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> T value)</span></span>;      <span class="comment">// 查找值为value的元素，并返回第1次出现的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>头结点Header Node（或称“哨兵” ）不被作为表中的实际元素，值忽略。head指向该节点，必须从head开始查找链表中的元素</p>
</li>
<li><p>头结点的好处</p>
<ol>
<li>由于开始结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作就和在表的其它位置上操作一致，无须进行特殊处理</li>
<li>无论链表是否为空，其头指针是指向头结点的非空指针（空表中头结点的指针域空），因此空表和非空表的处理也就统一了</li>
</ol>
</li>
</ul>
<h3 id="链表检索"><a href="#链表检索" class="headerlink" title="链表检索"></a>链表检索</h3><ul>
<li><p>由于地址空间不连续，单链表无法像顺序表那样直接通过结点位置来定位其地址，而是需要从头指针head所指的首结点开始沿next域，逐个结点进行访问</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回位置i处的结点指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;    <span class="comment">// 线性表的元素类型为T</span></span><br><span class="line">Link&lt;T&gt; * lnkList &lt;T&gt;:: <span class="built_in">setPos</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">-1</span>)    <span class="keyword">return</span> head;    <span class="comment">//  i 为-1则定位到头结点</span></span><br><span class="line">    Link&lt;T&gt; *p = head-&gt;next; </span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; count &lt; i) </span><br><span class="line">    &#123;   <span class="comment">// 若i为0则定位到第1个结点 </span></span><br><span class="line">        p = p-&gt; next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;   <span class="comment">// 或者为空，或者指向第i个节点！</span></span><br><span class="line">&#125;;    <span class="comment">// i从0开始！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>平均需要O(n)的时间</p>
</li>
</ul>
<h3 id="链表的插入和删除"><a href="#链表的插入和删除" class="headerlink" title="链表的插入和删除"></a>链表的插入和删除</h3><ul>
<li><p>链表插入: bool insert(int i, T value)</p>
</li>
<li><p>由于单链表结点之间的前驱后继关系由指针来表示，因此在插入或删除结点时，维护结点之间的逻辑关系只需要改变相关结点的next域</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/lgy7fk6AxcTIzos.png" alt=" 2024-09-23 181100.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *p，*q;</span><br><span class="line">    q = <span class="keyword">new</span> ListNode;                 	 <span class="comment">//产生一个新结点空间q</span></span><br><span class="line">    p = <span class="built_in">setPos</span>(i<span class="number">-1</span>);                     <span class="comment">//找到待插位置的前一个位置p</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> )  <span class="keyword">return</span> <span class="literal">false</span>; 	 <span class="comment">//位置i无效</span></span><br><span class="line">    q-&gt;data = value; 	</span><br><span class="line">    q-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next == <span class="literal">NULL</span> ) 		</span><br><span class="line">        tail=q; 		        <span class="comment">//当插入元素是最后位置时维护尾指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>链表删除: bool delete(int i)</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/icnmFdroLzqta3x.png" alt=" 2024-09-23 181541.png"></p>
<ul>
<li>与插入操作相同，从单链表中删除一个节点也需要修改被删除结点的前驱的指针域来维护结点见的线性关系，同时要释放被删除结点所占用的内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  			<span class="comment">// 线性表的元素类型为T</span></span><br><span class="line"><span class="type">bool</span> lnkList&lt;T&gt;:: <span class="built_in">delete</span>(<span class="type">const</span> <span class="type">int</span> i) </span><br><span class="line">&#123;</span><br><span class="line">    Link&lt;T&gt; *p, *d; </span><br><span class="line">    <span class="keyword">if</span> ((p = <span class="built_in">setPos</span>(i<span class="number">-1</span>)) == <span class="literal">NULL</span>  ||  p == tail) </span><br><span class="line">    &#123;  <span class="comment">// 待删结点不存在;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; 非法删除点 &quot;</span> &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = p-&gt;next;	               <span class="comment">// d是真正待删结点</span></span><br><span class="line">    <span class="keyword">if</span> (d == tail)</span><br><span class="line">    &#123;	  	<span class="comment">// 待删结点为尾结点，则修改尾指针</span></span><br><span class="line">        tail = p;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>:</span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;  </span><br><span class="line">        p-&gt;next = d-&gt;next; </span><br><span class="line">        <span class="keyword">delete</span> d;</span><br><span class="line">    &#125;   <span class="comment">// 删除结点d并修改链指针  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽管插入删除操作本身可在常数时间内完成节点的创建释放和链接信息的修改，但在位置i进行插入删除操作时，需要先定位到位置i-1的结点，而定位操作的平均时间代价为O(n)</li>
</ul>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><ul>
<li><p>单链表的不足：其指针域仅指向其后继结点，因此从一个结点不能有效的找到其前驱，而补习从表首开始顺着next域逐一查找</p>
</li>
<li><p>双链表的基本思路：每个结点中再增加一个指向前驱的指针。其中next表示指向后继的指针，prev表示指向其前驱的指针</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/2S6gv9VQZK7DXA5.png" alt=" 2024-09-23 182918.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T data;               <span class="comment">// 用于保存结点元素的内容</span></span><br><span class="line">        Link&lt;T&gt; * next;       <span class="comment">// 指向后继结点的指针</span></span><br><span class="line">        Link&lt;T&gt; * prev;       <span class="comment">// 指向前驱结点的指针</span></span><br><span class="line">        <span class="built_in">Link</span>(<span class="type">const</span> T info,Link&lt;T&gt; * preValue = <span class="literal">NULL</span>,link&lt;T&gt; * nextValue = <span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//构造函数：值和前后继指针</span></span><br><span class="line">            data = info;</span><br><span class="line">            next = nextValue;</span><br><span class="line">            prev = preValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Link</span>(Link&lt;T&gt; * preValue = <span class="literal">NULL</span>,Link&lt;T&gt; * nextValue = <span class="literal">NULL</span>)</span><br><span class="line">        &#123;<span class="comment">//给定前后指针的构造函数</span></span><br><span class="line">            next = nextValue;</span><br><span class="line">            prev = preValue;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="链表的插入和删除-1"><a href="#链表的插入和删除-1" class="headerlink" title="链表的插入和删除"></a>链表的插入和删除</h3><ul>
<li><p>与单链表不同，若要删除双链表中的一个结点，则不仅要修改该结点的前驱的next域，还要修改该结点后继的prev域</p>
</li>
<li><p>删除一个结点：</p>
<ol>
<li>维护前驱和后继两条链</li>
<li>然后吧变量p的前驱和后继置空，再释放p所指的空间</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/MUgLvuiJdbIQmSa.png" alt=" 2024-09-23 183750.png"></p>
<ul>
<li>插入一个新结点：<ol>
<li>执行new q开辟新的结点空间</li>
<li>填写新结点的数据域信息</li>
<li>填写新结点在链表中的链接关系</li>
<li>修改p所指结点及其后继结点在新结点插入后的链接信息</li>
</ol>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/EDIB46oFrvjZfOp.png" alt=" 2024-09-23 183846.png"></p>
<ul>
<li>尽管双链表的空间开销比单链表稍多，但可在O(1)时间内找到给定元素的前驱</li>
</ul>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><ul>
<li><p>某些情况需要把结点组成循环链表，将单链表或者双链表的头尾结点链接起来，就是一个循环链表</p>
</li>
<li><p>从循环表中任一结点出发，都能访问到表中其他结点</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/09/23/1Ldt8IYJFsAX4iT.png" alt=" 2024-09-23 184504.png"></p>
<p><img src="https://s2.loli.net/2024/09/23/txTvR6Q2oY8a3JL.png" alt=" 2024-09-23 184519.png"></p>
<h1 id="线性表实现方法的比较"><a href="#线性表实现方法的比较" class="headerlink" title="线性表实现方法的比较"></a>线性表实现方法的比较</h1><ul>
<li><p>顺序表具有易用、空间开发小、对任意元素进行随机访问的特点，是静态数据的理想选择</p>
</li>
<li><p>链表具有适用于频繁插入删除内部元素，管理长度变化的特点，是动态数据的理想选择</p>
</li>
<li><p>不要使用顺序表的场合：经常插入删除内部元素，无法确定长度的最大值</p>
</li>
<li><p>不要使用链表的场合：经常对线性表进行按位置的访问，而且按位读操作比插入删除操作频繁时，存储开销要求小时</p>
</li>
</ul>
<hr>
<h1 id="第二章-线性表-OJ作业"><a href="#第二章-线性表-OJ作业" class="headerlink" title="第二章 线性表 OJ作业"></a>第二章 线性表 OJ作业</h1><h2 id="1：放苹果"><a href="#1：放苹果" class="headerlink" title="1：放苹果"></a>1：放苹果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*描述</span></span><br><span class="line"><span class="comment">把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">对输入的每组数据M和N，用一行输出相应的K。</span></span><br><span class="line"><span class="comment">样例输入</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">7 3</span></span><br><span class="line"><span class="comment">样例输出</span></span><br><span class="line"><span class="comment">8*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(m, n - <span class="number">1</span>) + <span class="built_in">f</span>(m - n, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">f</span>(m, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, M, N;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">        <span class="type">int</span> K;</span><br><span class="line">        K = <span class="built_in">f</span>(M, N);</span><br><span class="line">        cout &lt;&lt; K &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2：Number-Sequence"><a href="#2：Number-Sequence" class="headerlink" title="2：Number Sequence"></a>2：Number Sequence</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*描述</span></span><br><span class="line"><span class="comment">A single positive integer i is given. Write a program to find the digit located in the position i in the sequence of number groups S1S2...Sk.</span></span><br><span class="line"><span class="comment">Each group Sk consists of a sequence of positive integer numbers ranging from 1 to k, written one after another.</span></span><br><span class="line"><span class="comment">For example, the first 80 digits of the sequence are as follows:</span></span><br><span class="line"><span class="comment">11212312341234512345612345671234567812345678912345678910123456789101112345678910</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">The first line of the input file contains a single integer t (1 ≤ t ≤ 10), the number of test cases, followed by one line for each test case.</span></span><br><span class="line"><span class="comment">The line for a test case contains the single integer i (1 ≤ i ≤ 2147483647)</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">There should be one output line per test case containing the digit located in the position i.</span></span><br><span class="line"><span class="comment">样例输入</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">样例输出</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">2*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 函数 Generate(int n)：生成从 1 到 n 的所有整数的字符串形式，拼接成一个长字符串</span></span><br><span class="line"><span class="function">string <span class="title">Generate</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string c; <span class="comment">// 用于保存拼接后的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c += <span class="built_in">to_string</span>(i); <span class="comment">// 调用函数 a，将每个整数 i 转换为字符串并拼接到 c</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c; <span class="comment">// 返回拼接后的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数 num(int n)：计算从 1 到 n 之间的所有整数的位数总和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;      <span class="comment">// k 表示当前位数范围的起始值，比如 1, 10, 100,...</span></span><br><span class="line">    <span class="type">int</span> dTotal = <span class="number">0</span>; <span class="comment">// dTotal 用于累计位数总和</span></span><br><span class="line">    <span class="type">int</span> left = n;   <span class="comment">// mleft 表示剩余的数字个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">9</span> * k)</span><br><span class="line">        &#123;</span><br><span class="line">            dTotal += <span class="number">9</span> * k * i; <span class="comment">// 累计所有 k 位数的总位数，9*k 是 k 位数的数量，i 是位数</span></span><br><span class="line">            left -= <span class="number">9</span> * k;       <span class="comment">// 减去 k 位数的数量</span></span><br><span class="line">            k *= <span class="number">10</span>;             <span class="comment">// k 进一位（从 1 到 10，从 10 到 100）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dTotal += (n - k + <span class="number">1</span>) * i; <span class="comment">// 如果剩下的数字不足 k 位数，直接计算并跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dTotal; <span class="comment">// 返回从 1 到 n 之间的位数总和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数 ans(int i)：输出第 i 位上的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ans</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">1000000</span>; j++) <span class="comment">// 遍历 j，寻找包含第 i 位的整数范围</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">num</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (c &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            string d = <span class="built_in">Generate</span>(j); <span class="comment">// 生成从 1 到 j 的完整拼接字符串</span></span><br><span class="line">            <span class="type">int</span> k = d[c - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 找到第 c 个字符，并将其转换为整数</span></span><br><span class="line">            cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            c -= m; <span class="comment">// 如果第 i 位在后面的数字范围中，减去前面的总位数，继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="built_in">ans</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3：神奇的幻方"><a href="#3：神奇的幻方" class="headerlink" title="3：神奇的幻方"></a>3：神奇的幻方</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*描述</span></span><br><span class="line"><span class="comment">幻方是一个很神奇的N*N矩阵，它的每行、每列与对角线，加起来的数字和都是相同的。</span></span><br><span class="line"><span class="comment">我们可以通过以下方法构建一个幻方。（阶数为奇数）</span></span><br><span class="line"><span class="comment">1.第一个数字写在第一行的中间</span></span><br><span class="line"><span class="comment">2.下一个数字，都写在上一个数字的右上方：</span></span><br><span class="line"><span class="comment">    a.如果该数字在第一行，则下一个数字写在最后一行，列数为该数字的右一列</span></span><br><span class="line"><span class="comment">    b.如果该数字在最后一列，则下一个数字写在第一列，行数为该数字的上一行</span></span><br><span class="line"><span class="comment">    c.如果该数字在右上角，或者该数字的右上方已有数字，则下一个数字写在该数字的下方</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">一个数字N（N&lt;=20）</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">按上方法构造的2N-1 * 2N-1的幻方</span></span><br><span class="line"><span class="comment">样例输入</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">样例输出</span></span><br><span class="line"><span class="comment">17 24 1 8 15</span></span><br><span class="line"><span class="comment">23 5 7 14 16</span></span><br><span class="line"><span class="comment">4 6 13 20 22</span></span><br><span class="line"><span class="comment">10 12 19 21 3</span></span><br><span class="line"><span class="comment">11 18 25 2 9*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Put</span><span class="params">(<span class="type">int</span> array[MAX][MAX], <span class="type">int</span> index, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == size * size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> newX = (x - <span class="number">1</span> + size) % size;</span><br><span class="line">    <span class="type">int</span> newY = (y + <span class="number">1</span>) % size;</span><br><span class="line">    <span class="keyword">if</span> (array[newX][newY] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newX = (x + <span class="number">1</span>) % size;</span><br><span class="line">        newY = y;</span><br><span class="line">    &#125;</span><br><span class="line">    array[newX][newY] = index + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Put</span>(array, index + <span class="number">1</span>, newX, newY, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">2</span> * N - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> array[MAX][MAX];</span><br><span class="line">    <span class="built_in">memset</span>(array, <span class="number">0</span>, <span class="built_in">sizeof</span>(array));</span><br><span class="line">    array[<span class="number">0</span>][N - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Put</span>(array, <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>, size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; array[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/">数据结构与算法A</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/8c2d9c9a.html" title="AI中的编程 Parallel Communication"><img class="cover" src="https://s2.loli.net/2024/09/14/KdVleb7SUc4EvZR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">AI中的编程 Parallel Communication</div></div></a></div><div class="next-post pull-right"><a href="/post/ce4c244d.html" title="数据结构与算法A 第一章概论"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据结构与算法A 第一章概论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/ce4c244d.html" title="数据结构与算法A 第一章概论"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="title">数据结构与算法A 第一章概论</div></div></a></div><div><a href="/post/5990a231.html" title="数据结构与算法A 第三章栈与队列"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="title">数据结构与算法A 第三章栈与队列</div></div></a></div><div><a href="/post/3571a0c4.html" title="数据结构与算法A 第四章字符串"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-01</div><div class="title">数据结构与算法A 第四章字符串</div></div></a></div><div><a href="/post/ef4da500.html" title="数据结构与算法A 第五章二叉树"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="title">数据结构与算法A 第五章二叉树</div></div></a></div><div><a href="/post/c353c3c1.html" title="数据结构与算法A 第六章树"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-30</div><div class="title">数据结构与算法A 第六章树</div></div></a></div><div><a href="/post/c047bfd7.html" title="数据结构与算法A 第七章图"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-11</div><div class="title">数据结构与算法A 第七章图</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/07/16/lsEXfWtGT6eRu7k.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">w434</div><div class="author-info__description">An undergraduate majoring in AI at PKU.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">29</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/w434"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/w434" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcom to my blog.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">线性表的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">线性表的抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">线性表的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%BF%90%E7%AE%97%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">线性表运算分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">顺序表的类定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表的运算实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%A3%80%E7%B4%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">顺序表的检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">顺序表的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">顺序表的删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%A3%80%E7%B4%A2"><span class="toc-number">3.1.1.</span> <span class="toc-text">链表检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">链表的插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">链表的插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">循环链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.</span> <span class="toc-text">线性表实现方法的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8-OJ%E4%BD%9C%E4%B8%9A"><span class="toc-number">5.</span> <span class="toc-text">第二章 线性表 OJ作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%9A%E6%94%BE%E8%8B%B9%E6%9E%9C"><span class="toc-number">5.1.</span> <span class="toc-text">1：放苹果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%9ANumber-Sequence"><span class="toc-number">5.2.</span> <span class="toc-text">2：Number Sequence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%9A%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B9%BB%E6%96%B9"><span class="toc-number">5.3.</span> <span class="toc-text">3：神奇的幻方</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/e232842e.html" title="Janus:Decoupling Visual Encoding for Unified Multimodel Understanding and Generation"><img src="https://s2.loli.net/2025/02/22/PtwTxgJ8dYWh2IZ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Janus:Decoupling Visual Encoding for Unified Multimodel Understanding and Generation"/></a><div class="content"><a class="title" href="/post/e232842e.html" title="Janus:Decoupling Visual Encoding for Unified Multimodel Understanding and Generation">Janus:Decoupling Visual Encoding for Unified Multimodel Understanding and Generation</a><time datetime="2025-02-22T05:55:00.000Z" title="Created 2025-02-22 13:55:00">2025-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/30f06d20.html" title="DeepSeek-R1:Incentivizing Reasoning Capability in LLMs via Reinforcement Learning"><img src="https://s2.loli.net/2025/02/21/D6Cb5LuMrkVQeiz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeepSeek-R1:Incentivizing Reasoning Capability in LLMs via Reinforcement Learning"/></a><div class="content"><a class="title" href="/post/30f06d20.html" title="DeepSeek-R1:Incentivizing Reasoning Capability in LLMs via Reinforcement Learning">DeepSeek-R1:Incentivizing Reasoning Capability in LLMs via Reinforcement Learning</a><time datetime="2025-02-21T04:36:00.000Z" title="Created 2025-02-21 12:36:00">2025-02-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/e0e02130.html" title="计算机视觉 22 Image Generation"><img src="https://s2.loli.net/2024/11/18/zAG9fYxh35LIWK2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机视觉 22 Image Generation"/></a><div class="content"><a class="title" href="/post/e0e02130.html" title="计算机视觉 22 Image Generation">计算机视觉 22 Image Generation</a><time datetime="2025-02-14T11:06:00.000Z" title="Created 2025-02-14 19:06:00">2025-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4ff2381f.html" title="计算机视觉 21 Image Segmentation"><img src="https://s2.loli.net/2024/11/18/zAG9fYxh35LIWK2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机视觉 21 Image Segmentation"/></a><div class="content"><a class="title" href="/post/4ff2381f.html" title="计算机视觉 21 Image Segmentation">计算机视觉 21 Image Segmentation</a><time datetime="2025-02-14T04:30:00.000Z" title="Created 2025-02-14 12:30:00">2025-02-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/3b6aa2ce.html" title="计算机视觉 20 RNN and Transformers"><img src="https://s2.loli.net/2024/11/18/zAG9fYxh35LIWK2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机视觉 20 RNN and Transformers"/></a><div class="content"><a class="title" href="/post/3b6aa2ce.html" title="计算机视觉 20 RNN and Transformers">计算机视觉 20 RNN and Transformers</a><time datetime="2025-02-07T12:01:00.000Z" title="Created 2025-02-07 20:01:00">2025-02-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By w434</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcom to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>