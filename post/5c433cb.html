<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>可视计算与交互概论 notes整理第12-14章 | w434's blog</title><meta name="author" content="w434"><meta name="copyright" content="w434"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第十二章 光照和着色什么是着色 着色（shading）:为几何体的表面加上材质的过程，或者说着色是绘制几何体表面的颜色使得它看起来像我们设定的材质的过程  光照 一个物体除非自己发光，否则都需要反射来自外界的光线进入人眼才能被我们看到  光源：源头的光照   平行光 因为太阳离地球很远，所以来自太阳的光线可以近似当成平行光（directional light）  可以用光照的方向和强度这两个量来描">
<meta property="og:type" content="article">
<meta property="og:title" content="可视计算与交互概论 notes整理第12-14章">
<meta property="og:url" content="http://example.com/post/5c433cb.html">
<meta property="og:site_name" content="w434&#39;s blog">
<meta property="og:description" content="第十二章 光照和着色什么是着色 着色（shading）:为几何体的表面加上材质的过程，或者说着色是绘制几何体表面的颜色使得它看起来像我们设定的材质的过程  光照 一个物体除非自己发光，否则都需要反射来自外界的光线进入人眼才能被我们看到  光源：源头的光照   平行光 因为太阳离地球很远，所以来自太阳的光线可以近似当成平行光（directional light）  可以用光照的方向和强度这两个量来描">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg">
<meta property="article:published_time" content="2024-11-11T09:52:00.000Z">
<meta property="article:modified_time" content="2024-11-15T09:39:02.979Z">
<meta property="article:author" content="w434">
<meta property="article:tag" content="可视计算与交互概论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/5c433cb.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '可视计算与交互概论 notes整理第12-14章',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-15 17:39:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/07/16/lsEXfWtGT6eRu7k.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa-solid fa-school"></i><span> 课程笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-face-smile"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/matches/"><i class="fa-fw fa-solid fa-futbol"></i><span> 足球赛事</span></a></li><li><a class="site-page child" href="/chess/"><i class="fa-fw fa-solid fa-chess"></i><span> 国际象棋</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-solid fa-film"></i><span> 影评&amp;演出评论&amp;书评</span></a></li><li><a class="site-page child" href="/jottings/"><i class="fa-fw fa-solid fa-book"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/varietyShow/"><i class="fa-fw fa-solid fa-tv"></i><span> 综艺</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa-solid fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/musics/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="w434's blog"><span class="site-name">w434's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa-solid fa-school"></i><span> 课程笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa-regular fa-face-smile"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/matches/"><i class="fa-fw fa-solid fa-futbol"></i><span> 足球赛事</span></a></li><li><a class="site-page child" href="/chess/"><i class="fa-fw fa-solid fa-chess"></i><span> 国际象棋</span></a></li><li><a class="site-page child" href="/comments/"><i class="fa-fw fa-solid fa-film"></i><span> 影评&amp;演出评论&amp;书评</span></a></li><li><a class="site-page child" href="/jottings/"><i class="fa-fw fa-solid fa-book"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/varietyShow/"><i class="fa-fw fa-solid fa-tv"></i><span> 综艺</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fa-solid fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/musics/"><i class="fa-fw fa-solid fa-music"></i><span> 音乐</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">可视计算与交互概论 notes整理第12-14章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-11-11T09:52:00.000Z" title="Created 2024-11-11 17:52:00">2024-11-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-11-15T09:39:02.979Z" title="Updated 2024-11-15 17:39:02">2024-11-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%8F%AF%E8%A7%86%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%A4%E4%BA%92%E6%A6%82%E8%AE%BA/">可视计算与交互概论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="可视计算与交互概论 notes整理第12-14章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第十二章-光照和着色"><a href="#第十二章-光照和着色" class="headerlink" title="第十二章 光照和着色"></a>第十二章 光照和着色</h1><h2 id="什么是着色"><a href="#什么是着色" class="headerlink" title="什么是着色"></a>什么是着色</h2><ul>
<li>着色（shading）:为几何体的表面加上材质的过程，或者说着色是绘制几何体表面的颜色使得它看起来像我们设定的材质的过程</li>
</ul>
<h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><ul>
<li><p>一个物体除非自己发光，否则都需要反射来自外界的光线进入人眼才能被我们看到</p>
</li>
<li><p>光源：源头的光照</p>
</li>
</ul>
<h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><ul>
<li><p>因为太阳离地球很远，所以来自太阳的光线可以近似当成平行光（directional light）</p>
</li>
<li><p>可以用光照的方向和强度这两个量来描述平行光：</p>
<ol>
<li>方向表示为世界坐标中的归一化三维向量 d</li>
<li>强度定义为垂直于光入射方向单位面积上接收到的光照射的功率</li>
</ol>
</li>
<li><p>光强需要在光的垂直方向测量，接收光的表面与入射光线之间存在夹角 θ，相同的平面面积接收到的光强与 θ 相关。由于平面面积投影到光的垂直方向需要乘以一个因子 cos θ，所以图右边的平面接收到的光强就是左边的 cos θ 倍，也就意味着光强比左边直射时更小。如果平面与光的方向完全平行，cos θ &#x3D; 0，表示接收到的光强为 0</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/ZmGPr7LEaOYykSz.png" alt="image.png"></p>
<ul>
<li>用一个颜色 Id 表示平行光的光强，其三个分量表示 RGB 三个频率范围内的光强分量，这样当入射光线与平面法线之间的夹角是 θ 时，平面接收到的光强就是 Idcos θ</li>
</ul>
<h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><ul>
<li><p>在阴影的暗部也不是完全黑暗的，这一部分区域就是由环境光（ambient light）照亮的</p>
</li>
<li><p>环境光来自四面八方，是太阳光经过云层大气的散射以及其他物体的反射得到的，因此环境光是一种间接光照（indirection illumination）</p>
</li>
<li><p>在最简单的模型中，我们可以认为环境光在各个方向是均匀的，于是只需要一个光强 Ia 就能定义环境光</p>
</li>
</ul>
<h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><ul>
<li><p>蜡烛、灯泡等可以近似描述为点光源（point light）</p>
</li>
<li><p>点光源没有方向性，但是与环境光不同，点光源的强度会随着距离衰减。在远处接收到的光强要远远小于光源中心附近的光强，这个衰减的比率可以计算得到是 1&#x2F;r²，r 表示观测点与点光源的距离</p>
</li>
<li><p>描述点光源，我们需要记录点光源的位置 p，以及单位长度处的强度 Ip，这样在距离为 r 的地方接收到的光强就能表示为 Ip&#x2F;r²</p>
</li>
</ul>
<h2 id="反射模型"><a href="#反射模型" class="headerlink" title="反射模型"></a>反射模型</h2><ul>
<li>反射模型要研究光线经过物体表面反射之后入射到摄像机中的光强</li>
</ul>
<h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p><img src="https://s2.loli.net/2024/11/11/gdjVSAlP7DfyWpC.png" alt="image.png"></p>
<ul>
<li><p>漫反射（diffuse reflection）：当物体的表面极度粗糙不平时，入射到表面上的光线会被反射到各个方向</p>
</li>
<li><p>朗伯体（Lambert body）：当物体表面只有完全随机的漫反射</p>
</li>
<li><p>朗伯体的特点在于其在各个角度看起来反射的光强都是相同的，这符合我们日常生活中对于粗糙表面的直觉</p>
</li>
<li><p>对于完全的漫反射而言，其反射到摄像机中的光强可以写为：Ld &#x3D; kd(Ia + Id max(0, n · l))。其中 kd 是表面的漫反射颜色，n 是表面法向，l 是光源的方向：</p>
<ol>
<li>kd 是表面漫反射的颜色，尽管表面在空间角度上均匀反射入射光线，但是在频率空间上并不是均匀的，有的频率被表面吸收，有的频率被反射，漫反射的颜色也就表示表面在RGB 三个分量上的反射系数</li>
<li>Ia 和 Id 分别表示环境光和平行光的强度，存在点光源时只需要把 Id 替换为 Ip&#x2F;r²即可</li>
<li>n · l 得到的就是 cos θ，也就是我们在前面平行光部分介绍的表面与入射光线方向不垂直带来的系数，与 0 求 max 表示只有当光源在法向一侧时表面才能被照射到，否则就处在阴影中</li>
</ol>
</li>
</ul>
<h3 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h3><p><img src="https://s2.loli.net/2024/11/11/cSAfqUIxsHoPCwm.png" alt="image.png"></p>
<ul>
<li><p>与漫反射相对的就是镜面反射（specular reflection）</p>
</li>
<li><p>理想的镜面反射满足反射定律：光线的出射角等于入射角</p>
</li>
<li><p>理想的镜面反射要求物体表面非常光滑，一般情况下我们可以认为反射光线分布于理想反射光线 r 附近的圆锥内，中心最强，边缘比较弱</p>
</li>
<li><p>用数学表示反射光的分布：衡量 v 和理想镜面反射光线 r 的接近程度，给观察到的光强乘以一个对应的衰减因子，在 v 与 r 重合时为 1，在 v 和 r 距离很远的时候为 0</p>
</li>
<li><p>计算 r：将 l 分解到 n 的方向和垂直于 n 的方向，延 n 的方向不变，垂直于 n 的方向反号，这样就能得到 r</p>
</li>
<li><p>规避掉直接求解 r 从而简化计算：定义半程向量 h &#x3D; normalized((l+v)&#x2F;2)，并且计算 h 与 n 之间的夹角 α 。当 v 正好沿着 r 的方向时，半程向量 h 应该正好沿着 n 方向，而随着 v 逐渐远离 r，α 也在逐渐增大。于是 α 可以正确度量 v 和 r 之间的差异，同时 h 在计算上要更简单，所以我们可以用 α 来计算光强衰减的因子 cos α (在 α &#x3D; 0 时取到 1，在 α 增大的时候的逐渐减小)</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/ipzRVCWqh2dFHEj.png" alt="image.png"></p>
<ul>
<li>镜面反射的公式：Ls &#x3D; ksId max(0, n · h) ^ p<ol>
<li>公式里 ks、Id、max 的含义与漫反射公式一致</li>
<li>公式的最后多乘了一个p 次方，这个参数 p 是用来控制镜面反射的集中度的。当 p 比较小时 cosα ^ p 衰减比较慢，表示光线比较分散，表面比较粗糙；当 p 比较大时，cosα ^ p 衰减快，表示光线集中，表面比较光滑<br>  <img src="https://s2.loli.net/2024/11/11/QFTavgW3wN1epht.png" alt="image.png"></li>
</ol>
</li>
</ul>
<h3 id="Blinn-Phong-反射模型"><a href="#Blinn-Phong-反射模型" class="headerlink" title="Blinn-Phong 反射模型"></a>Blinn-Phong 反射模型</h3><ul>
<li><p>Blinn-Phong 反射模型：一般的物体我们可以认为同时存在漫反射和镜面反射，结合公式我们就得到了一般物体的反射模型</p>
</li>
<li><p>Blinn-Phong 反射的公式：L &#x3D; kd(Ia + Id max(0, n · l)) + ksId max(0, n · h) ^ p</p>
</li>
<li><p>至于 Blinn-Phong 之前的 Phong 模型，其实就是前面介绍的在计算镜面反射时计算视线与反射光线之间的夹角，而非半程向量与法线之间的夹角</p>
</li>
</ul>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><ul>
<li><p>可以通过光栅化来将虚拟的几何和材质转化为屏幕上的像素。那么与之相对应的我们就需要解决两个问题：</p>
<ol>
<li>如何确定每个三角形面片上每个像素的颜色</li>
<li>是如何处理三角形之间的遮挡关系</li>
</ol>
</li>
<li><p>深度缓存来处理三角形之间的遮挡:每个像素中除了记录颜色信息，同时还记录了深度信息；每个三角形都需要进行逐像素的深度检测，最终只保留深度最小的颜色</p>
</li>
<li><p>确定像素的深度：利用像素在屏幕空间中的位置和每个顶点经过变换后的平面位置和深度，在屏幕空间中的位置通过插值得到深度，使用我们在之前二维图像绘制中介绍的双线性插值的方法，或者等价的使用重心坐标</p>
</li>
<li><p>对于三角形中的任意一点，可以使用其分割出的三个小三角形之间的比值计算出其相对于三个顶点的权重：相对于点 A 的权重 α 是与 A 点不相邻的小三角形与大三角形的面积比值。当顶点位于点 A 时，满足α &#x3D; 1, β &#x3D; γ &#x3D; 0，α + β + γ &#x3D; 1。并且由于面积随着顶点位置线性变化，三个权重也会随着位置线性变化。因此，顶点上的深度、颜色等信息，可以使用 α、β、γ 三个权重加权平均三角形顶点上的值得到</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/lDIYGWt2oKCk5T4.png" alt="image.png"></p>
<ul>
<li><p>但不管我们使用什么在屏幕空间的线性插值方法，得到的深度是不准确的</p>
</li>
<li><p>考虑二维情况，这时相机的近平面就是一条直线，(Xa, Za) 到 (Xb, Zb)之间的线段经过投影变换变换到了 (xa, znear) 到 (xb, znear)。假设 xa 和 xb 上下对称，考虑它们中点像素 Q 的深度。如果直接用屏幕空间的 Q 点做插值那么就会得到 Q 点的深度是 (Za + Zb)&#x2F;2．然而 Q 点的深度应该由其在原线段上的点 P 决定，P 显然并不位于原线段的中点上，因此真实的 Q 点的深度并不是 (Za + Zb)&#x2F;2</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/AWwMVUbjYoTrvJP.png" alt="image.png"></p>
<ul>
<li><p>发生这个错误的原因在于透视投影变换是非线性的，重心坐标依赖于三角形的面积（二维中是长度），而透视投影并不能保证所有点面积均匀缩放</p>
</li>
<li><p>正确的做法是在透视投影前做插值，需反求每个像素在投影前的位置，然后在三维空间中线性插值</p>
</li>
<li><p>透视矫正插值（Perspective-CorrectInterpolation）：假设我们需要对三角形的三个顶点上的值 fa, fb, fc 进行插值，透视矫正投影的公式表述为：其中 α, β, γ 是使用屏幕坐标求得的重心坐标，wa, wb, wc 是透视投影之后得到的齐次坐标的第四个分量</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/4LRPzQaEMvXCmnK.png" alt="image.png"></p>
<ul>
<li><p>这个公式表明透视投影对于插值的影响只是在重心权重上多乘了一个 1 &#x2F; w 的因子。参照透视投影的矩阵公式，变换后齐次坐标的第四个分量 w 实际上就是顶点在变换前的深度 z</p>
</li>
<li><p>透视矫正下像素深度的插值公式：</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/Y4PTvx7b9BlmyAz.png" alt="image.png"></p>
<ul>
<li><p>使用透视矫正的方法插值深度，等价于在屏幕空间对 1&#x2F;z 进行线性插值，这也说明了我们之前对深度 z 直接进行线性插值是错误的</p>
</li>
<li><p>深度缓存技术也不是万能的，最大的问题在于计算的代价</p>
</li>
<li><p>背面剔除（Back Face Culling）可以减少时间代价：如果在场景中我们绘制的都是封闭的几何体，那么显然几何体的背面是永远不会出现在屏幕上的。我们只需要判断三角形的法向与视线方向是否同向，也就是 v · n &gt; 0。如果同向，那么这个三角形就是背面，我们也就不用费力再对它判断深度缓存和着色了</p>
</li>
</ul>
<h2 id="着色模型"><a href="#着色模型" class="headerlink" title="着色模型"></a>着色模型</h2><ul>
<li>在给定光照、物体几何和材质之后，决定像素颜色最关键的就是表面的法向</li>
</ul>
<h3 id="平面着色"><a href="#平面着色" class="headerlink" title="平面着色"></a>平面着色</h3><ul>
<li>平面着色（Flat Shading）：使用三角形的面法向，逐三角形确定颜色</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/G7wdU4m9sIcEOht.png" alt="image.png"></p>
<ul>
<li><p>在平面着色中，每个三角形只有一个法向，每个三角形只有一个颜色，于是我们能在渲染结果里看到很多独立的面片，但是我们还是可以直观看到整个形状上明暗的过渡以及高光</p>
</li>
<li><p>如果我们的三角面片足够多，我们就能得到一个光滑的表面，但是如何在三角形数量不够的时候依然让表面看起来光滑呢？这就引入了第二种着色方法</p>
</li>
</ul>
<h3 id="Gouraud-着色（Gouraud-Shading）"><a href="#Gouraud-着色（Gouraud-Shading）" class="headerlink" title="Gouraud 着色（Gouraud Shading）"></a>Gouraud 着色（Gouraud Shading）</h3><ul>
<li><p>Gouraud 着色（Gouraud Shading）：计算每个顶点的颜色，然后在三角形中间插值</p>
</li>
<li><p>在 Gouraud 着色中，不再是逐三角形着色，而是逐顶点着色。使用每个顶点的顶点法向计算光照颜色，然后在三角形内部用重心坐标进行插值</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/SsEkz2cPigVjAm9.png" alt="image.png"></p>
<ul>
<li><p>在曲面的大部分区域里我们得到了光滑的颜色过渡，但是在高光区域我们能明显看到三角形插值的痕迹。同样，如果我们增加三角形的数量，我们依然能够得到光滑的渲染结果，但是有没有方法能够在当前的精度下进一步减小离散化带来的误差？</p>
</li>
<li><p>如果三角形近似的曲面正对着光源方向，那么三角形中心的高光应该要强于顶点处的高光，这表明三角形中心的颜色并不能写成顶点颜色的线性插值，因为插值出来的亮度不可能强于被插值的顶点的亮度</p>
</li>
<li><p>因此对颜色插值并不是一个好的策略，我们需要考虑三角形内部颜色随位置的非线性变化</p>
</li>
</ul>
<h3 id="Phong-着色（Phong-Shading）"><a href="#Phong-着色（Phong-Shading）" class="headerlink" title="Phong 着色（Phong Shading）"></a>Phong 着色（Phong Shading）</h3><ul>
<li>Phong 着色（Phong Shading）：既然不能通过插值得到颜色，我们就只有对三角形上的每一个点都计算一个颜色，这样我们的着色方案就不再是逐顶点的，而是逐像素的</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/9ftvzOI2yebdPlx.png" alt="image.png"></p>
<ul>
<li><p>在 Phong 着色中我们需要单独计算每个像素的颜色，也就需要每个像素的法向</p>
</li>
<li><p>像素的法向与深度一样，需要在透视投影之前插值才能得到正确结果，因此我们需要使用如下公式进行透视矫正的重心坐标插值，同时在插值之后还需要归一化</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/11/4LRPzQaEMvXCmnK.png" alt="image.png"></p>
<ul>
<li>Phong 着色能够正确画出椭圆形的高光区域，不再有 Gouraud 着色的不自然高光了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>从平面着色到 Phong shading，我们发现我们需要计算的颜色数量在增加，从逐三角形到逐顶点再到逐像素，换句话说就是着色频率在增加，效果也在逐渐接近真实</p>
</li>
<li><p>最简单的绘制三维物体表面的方法：光栅化 + 深度缓存 +Phong 着色</p>
</li>
</ul>
<h2 id="风格化渲染"><a href="#风格化渲染" class="headerlink" title="风格化渲染"></a>风格化渲染</h2><p><img src="https://s2.loli.net/2024/11/11/Tk82if6SqyDhXJj.png" alt="image.png"></p>
<ul>
<li><p>风格化渲染，或非真实感渲染（Non-Photorealistic Rendering,NPR）：不同艺术风格的渲染结果，这些风格服务于不同的目的，比如游戏、教育、工业等等</p>
</li>
<li><p>风格化渲染的两个非常重要的特征：</p>
<ol>
<li>线，包括物体边缘的轮廓线，表示结构的结构线，表示光影的阴影线等等</li>
<li>艺术化的着色，在风格化渲染中，我们往往希望颜色有不同的艺术效果，比如卡通风格、冷暖色调、油画风格等等</li>
</ol>
</li>
<li><p>首先，我们需要绘制出物体的轮廓线。做法：</p>
<ol>
<li><p>通过物体的法线方向来判断物体的边缘位置。法线应该正好与视线方向垂直，也就是 v·n ≈ 0。因此我们可以判断当着色点的法向方向与视线方向点乘在 0 附近时，就绘制边缘线的颜色。这种方法虽然简单，但是得到的边缘性的粗细并不是一致的，如果判断范围过小，就会出现边缘线断裂，如果过大就看起来不再是一条线<br>  <img src="https://s2.loli.net/2024/11/12/oZTkNqmzwdRGaW5.png" alt="image.png"></p>
</li>
<li><p>程序化几何法避免了边缘性粗细不一致的问题。们绘制两遍几何体，第一遍只绘制几何体的背面，绘制颜色为边缘线的颜色，并且将几何体稍微向外扩展一点，第二遍再在背面之上绘制正面的几何体，这样没有被遮挡的部分就是边缘线了。需注意两点：</p>
<ol>
<li>在扩展背面的几何体时，需要每个顶点在法向上移动的距离在屏幕上最终是等宽的，不然还是会出现边缘线不等宽的现象．因此在计算移动距离时，我们需要考虑投影变换的影响</li>
<li>绘制正面的几何体时，需要使用深度缓存，不然的话我们就可能丢失一些物体上的轮廓线（比如茶壶盖的轮廓线）<br>  <img src="https://s2.loli.net/2024/11/12/BPvQYCStT2hkcfV.png" alt="image.png"></li>
</ol>
</li>
</ol>
</li>
<li><p>还可以在正常绘制结束之后，再从结果的图像中提取出边缘。提取边缘的方法可以使用前面图像章节介绍的卷积方法</p>
</li>
<li><p>为了避免颜色的干扰，我们也可以单独渲染一张法线图，提取出边缘线之后再跟正常图像合成</p>
</li>
<li><p>物体的体积感并不是通过光影来塑造的，而是通过颜色的冷暖塑造的</p>
</li>
<li><p>Gooch 着色(冷暖色着色)：由于冷暖色并没有明显的亮度区别，因此我们可以同时观察到物体的各个部分的细节，同时保有立体感，因此这种着色方法经常用于科学插图、工业设计中</p>
</li>
<li><p>在 Gooch 着色中，我们给定了一个冷色 kcool 和暖色 kwarm，物体上的颜色通过在这两个颜色之间插值得到。插值的系数由物体法向与视线之间的夹角决定，具体的插值公式为：其中 l 是指向光源的方向，n 是表面法线方向</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/12/lNaDpwJcIzXjESR.png" alt="image.png"></p>
<ul>
<li>在此基础上，我们还可以将连续的颜色变化变成阶梯状的分段颜色，这样就得到了卡通效果</li>
</ul>
<hr>
<h1 id="第十三章-图形管线"><a href="#第十三章-图形管线" class="headerlink" title="第十三章 图形管线"></a>第十三章 图形管线</h1><ul>
<li><p>现代的大型实时游戏场景中包含大量的三角形面片，为了让人眼不感到间断，每秒至少需要渲染 30 帧以上场景．在CPU 上想要串行执行这样规模的计算几乎是一件不可能的事情．为了高效地完成实时图形渲染，人们对渲染的流程进行了很长时间的优化和演进，最终形成了图形管线（GraphicsPipeline）</p>
</li>
<li><p>由于图形管线中很多操作可以进行高度并行化，专用图形硬件——GPU应运而生</p>
</li>
</ul>
<h2 id="光栅化渲染总结"><a href="#光栅化渲染总结" class="headerlink" title="光栅化渲染总结"></a>光栅化渲染总结</h2><ul>
<li><p>前置知识：</p>
<ol>
<li>如何在屏幕上绘制一个简单的三角形（遍历判断像素点是否位于三角形内）</li>
<li>如何在简单光源下给三角形着色（Bling-Phong 着色模型）</li>
<li>如何处理三角形的遮挡和走样问题（z-buffer，super-sampling）</li>
</ol>
</li>
<li><p>结合到一起可以实现一个基本的软件渲染（对应于使用 GPU 的硬件渲染）流程：</p>
<ol>
<li>输入待渲染模型（若干三角形面片及其光照属性）、各光源属性</li>
<li>对所有三角形，计算其顶点的投影坐标以及深度，存储其法向量等着色信息</li>
<li>取一个三角形，遍历判断所有像素是否在投影后的三角形内部</li>
<li>对三角形内的像素点，遍历所有光源，将着色叠加得到像素点颜色</li>
<li>计算三角形在此处的深度值，如果相对于 z-buffer 深度更浅，更新 z-buffer，并将此处颜色写入 framebuffer</li>
<li>对所有三角形进行 3-5 步操作</li>
<li>将 framebuffer 同步到显示器，渲染结果被显示在屏幕上<br>  <img src="https://s2.loli.net/2024/11/15/HWoAKZzsh5qtN2S.png" alt="image.png"></li>
</ol>
</li>
<li><p>渲染流程中首先对输入进行几何处理。基础的几何处理包括投影、计算顶点颜色等，简称 T&amp;L（Transform and Lighting）</p>
</li>
<li><p>几何处理输出的一系列三角形在接下来的步骤中被光栅化，得到处于三角形投影内部的像素点</p>
</li>
<li><p>这些像素点根据光源属性、光照模型以及后面我们要提到的纹理映射被着色，最后通过 z-buffer、alpha-blending 等算法确定最后的颜色输出，显示到屏幕上</p>
</li>
</ul>
<h2 id="图形管线与硬件-API"><a href="#图形管线与硬件-API" class="headerlink" title="图形管线与硬件 API"></a>图形管线与硬件 API</h2><ul>
<li><p>在 OpenGL 中，几何处理阶段被进一步细化为：</p>
<ol>
<li>顶点着色（Vertex Shading）</li>
<li>曲面细分（Tessellation）</li>
<li>几何着色（Geometry Shading）</li>
<li>顶点后处理（Vertex Post-Processing）</li>
<li>图元组装（Primitive Assembly）</li>
</ol>
</li>
<li><p>这些阶段中，顶点着色、曲面细分、几何着色是可编程的（使用 OpenGL 着色器语言 GLSL 编写），而其余部分在硬件驱动中实现，仅能通过一些选项调整其参数</p>
</li>
<li><p>需要手动编写的仅有顶点着色器（Vertex Shader）一项，这一项需要处理顶点到投影空间的坐标变换，并计算光照有关的输入数据</p>
</li>
<li><p>除此之外，顶点着色器还可以修改顶点的位置，利用这一特性可以实现刚体旋转、关节动画、软体拉伸变形、水面波纹、地形起伏等一系列复杂的特效</p>
</li>
<li><p>顶点着色器仅能修改顶点位置而不能增加&#x2F;删除顶点，为此 OpenGL 的图形管线后续加入了曲面细分和几何着色阶段，大大增加了几何处理阶段的自由发挥空间</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2024/11/15/rXmudaYCJkAjzKc.png" alt="image.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单顶点着色器的 GLSL 代码</span></span><br><span class="line"><span class="meta">#version 450</span></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in vec3 inPosition;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">1</span>) in vec3 inNormal;</span><br><span class="line"><span class="built_in">layout</span> (binding = <span class="number">0</span>) uniform GlobalUniformData </span><br><span class="line">&#123;</span><br><span class="line">    mat4 proj ;</span><br><span class="line">    mat4 view ;</span><br><span class="line">&#125; global_data ;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) out vec3 fragColor ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = global_data . proj ∗ global_data . view ∗ <span class="built_in">vec4</span> ( inPosition , <span class="number">1</span> . <span class="number">0</span> ) ;</span><br><span class="line">    fragColor = inNormal ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>#version 450声明这是 OpenGL 4.5 的着色器代码，in、out 分别修饰着色器的输入和输出，uniform 代表全局数据，layout 表示数据在内存中存储的顺序</p>
</li>
<li><p>整个几何处理的运行逻辑位于main函数中，gl_Position则是 OpenGL 定义的全局变量，表示输出的顶点位置，是顶点着色器中唯一必须输出的量</p>
</li>
<li><p>fragColor作为输出，后续将传给下面提到的片段着色器，其内容是可以自由指定的</p>
</li>
<li><p>光栅化过程是光栅化渲染的核心部分，这一部分被硬编码在 GPU 中，并针对性地做了大量优化，仅能通过参数微调</p>
</li>
<li><p>光栅化之后，GPU 并行处理的对象就不再是顶点，而是屏幕中的像素，对每一个像素的着色操作被定义在片段着色（Fragment Shading）阶段</p>
</li>
<li><p>这一阶段是可编程的，所有的光照、着色都在这一阶段完成，所编写的程序成为片段着色器（Fragment Shader）或像素着色器（Pixel Shader）</p>
</li>
<li><p>片段着色结束后，OpenGL 会对着色器的输出颜色根据深度、透明度等进行裁剪与混合，同时根据指定的反走样算法执行反走样操作．在 OpenGL 中，这些操作都是编码在 GPU 中的，无法自定义实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单片段着色器的 GLSL 代码</span></span><br><span class="line"><span class="meta">#version 450</span></span><br><span class="line">in vec3 fragColor ;</span><br><span class="line">out vec4 outColor ;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outColor = <span class="built_in">vec4</span> ( fragColor , <span class="number">1</span> . ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>#version 450声明这是 OpenGL 4.5 的着色器代码，in、out 分别修饰片段着色器的输入和输出，整个着色的运行逻辑位于main函数中</p>
</li>
<li><p>这里fragColor是与上面提到的顶点着色器中输出相对应的量．在 OpenGL 中，如果片段着色器的输入和顶点着色器输出的名称和类型都相同，那么 OpenGL 就会自动将二者关联起来</p>
</li>
<li><p>顶点着色器和像素着色器中都有类型为vec3的fragColor的参数，这就意味着像素着色器得到的输入是由顶点着色器的输出决定的</p>
</li>
<li><p>但与简单的参数传递不同，顶点着色器输出的是逐顶点的值，像素着色器接受的输入是逐像素的输入．这中间进行的转换正是光栅化这一步进行的操作</p>
</li>
<li><p>默认情况下，OpenGL 会把顶点着色器的输出通过我们上一章介绍的透视矫正的线性插值方法插值到每个像素上，喂给像素着色器使用．因此即使我们在像素着色器中没有进行任何的插值操作，直接输出得到的就是光滑插值之后的结果</p>
</li>
<li><p>Gouraud 着色与 Phong 着色之间的差别:</p>
<ol>
<li>Gouraud 着色就是在顶点着色器计算 Blinn-Phong 光照模型，输出得到颜色之后通过光栅化插值</li>
<li>Phong 着色是在顶点着色器输出每个顶点的位置、法向等信息，在像素着色器中计算 Blinn-Phong 光照模型</li>
</ol>
</li>
<li><p>OpenGL 提供了三种插值选项，由插值限定符（Interpolation Qualifier）决定:</p>
<ol>
<li>flat in vec3 fragColor 指这个变量在光栅化阶段不会进行插值，像素着色器会得到三角形第一个顶点上的值</li>
<li>noperspective in vec3 fragColor指这个变量会在屏幕空间做线性插值</li>
<li>smooth in vec3 fragColor 指这个变量会通过透视矫正的方法插值，默认情况可以去掉smooth不写</li>
</ol>
</li>
</ul>
<h2 id="专用图形硬件——GPU"><a href="#专用图形硬件——GPU" class="headerlink" title="专用图形硬件——GPU"></a>专用图形硬件——GPU</h2><p><img src="https://s2.loli.net/2024/11/15/Wrw3BjJemKupXMy.png" alt="image.png"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%AF%E8%A7%86%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%A4%E4%BA%92%E6%A6%82%E8%AE%BA/">可视计算与交互概论</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/post/c047bfd7.html" title="数据结构与算法A 第七章图"><img class="cover" src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据结构与算法A 第七章图</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/post/42c5f110.html" title="可视计算与交互概论 notes整理第1-4章"><img class="cover" src="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-12</div><div class="title">可视计算与交互概论 notes整理第1-4章</div></div></a></div><div><a href="/post/b19143e7.html" title="可视计算与交互概论 notes整理第5-7章"><img class="cover" src="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-16</div><div class="title">可视计算与交互概论 notes整理第5-7章</div></div></a></div><div><a href="/post/5f62da59.html" title="可视计算与交互概论 notes整理第8-11章"><img class="cover" src="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-21</div><div class="title">可视计算与交互概论 notes整理第8-11章</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/07/16/lsEXfWtGT6eRu7k.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">w434</div><div class="author-info__description">An undergraduate majoring in AI at PKU.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/w434"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/w434" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcom to my blog.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%85%89%E7%85%A7%E5%92%8C%E7%9D%80%E8%89%B2"><span class="toc-number">1.</span> <span class="toc-text">第十二章 光照和着色</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9D%80%E8%89%B2"><span class="toc-number">1.1.</span> <span class="toc-text">什么是着色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7"><span class="toc-number">1.2.</span> <span class="toc-text">光照</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%8C%E5%85%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">平行光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">环境光</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">1.2.3.</span> <span class="toc-text">点光源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">反射模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">漫反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">镜面反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">Blinn-Phong 反射模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">光栅化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">着色模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E7%9D%80%E8%89%B2"><span class="toc-number">1.5.1.</span> <span class="toc-text">平面着色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gouraud-%E7%9D%80%E8%89%B2%EF%BC%88Gouraud-Shading%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">Gouraud 着色（Gouraud Shading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Phong-%E7%9D%80%E8%89%B2%EF%BC%88Phong-Shading%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">Phong 着色（Phong Shading）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%8E%E6%A0%BC%E5%8C%96%E6%B8%B2%E6%9F%93"><span class="toc-number">1.7.</span> <span class="toc-text">风格化渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF"><span class="toc-number">2.</span> <span class="toc-text">第十三章 图形管线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.</span> <span class="toc-text">光栅化渲染总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF%E4%B8%8E%E7%A1%AC%E4%BB%B6-API"><span class="toc-number">2.2.</span> <span class="toc-text">图形管线与硬件 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%9B%BE%E5%BD%A2%E7%A1%AC%E4%BB%B6%E2%80%94%E2%80%94GPU"><span class="toc-number">2.3.</span> <span class="toc-text">专用图形硬件——GPU</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/5c433cb.html" title="可视计算与交互概论 notes整理第12-14章"><img src="https://s2.loli.net/2024/10/12/Vpne4IKYRGgU3cB.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="可视计算与交互概论 notes整理第12-14章"/></a><div class="content"><a class="title" href="/post/5c433cb.html" title="可视计算与交互概论 notes整理第12-14章">可视计算与交互概论 notes整理第12-14章</a><time datetime="2024-11-11T09:52:00.000Z" title="Created 2024-11-11 17:52:00">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c047bfd7.html" title="数据结构与算法A 第七章图"><img src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法A 第七章图"/></a><div class="content"><a class="title" href="/post/c047bfd7.html" title="数据结构与算法A 第七章图">数据结构与算法A 第七章图</a><time datetime="2024-11-11T07:54:00.000Z" title="Created 2024-11-11 15:54:00">2024-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/95054760.html" title="A National Character:The land of Peach Blossom in the U.K."><img src="https://s2.loli.net/2024/10/30/B2HnwZ3yvcDzX1E.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A National Character:The land of Peach Blossom in the U.K."/></a><div class="content"><a class="title" href="/post/95054760.html" title="A National Character:The land of Peach Blossom in the U.K.">A National Character:The land of Peach Blossom in the U.K.</a><time datetime="2024-10-30T10:47:00.000Z" title="Created 2024-10-30 18:47:00">2024-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c353c3c1.html" title="数据结构与算法A 第六章树"><img src="https://s2.loli.net/2024/09/18/j8wKWGfEBsblvNn.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法A 第六章树"/></a><div class="content"><a class="title" href="/post/c353c3c1.html" title="数据结构与算法A 第六章树">数据结构与算法A 第六章树</a><time datetime="2024-10-30T05:31:00.000Z" title="Created 2024-10-30 13:31:00">2024-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b285d6ec.html" title="AI中的数学 第三章随机向量"><img src="https://s2.loli.net/2024/10/11/Kfi7398o5p1kTE4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI中的数学 第三章随机向量"/></a><div class="content"><a class="title" href="/post/b285d6ec.html" title="AI中的数学 第三章随机向量">AI中的数学 第三章随机向量</a><time datetime="2024-10-27T05:59:00.000Z" title="Created 2024-10-27 13:59:00">2024-10-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By w434</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcom to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>